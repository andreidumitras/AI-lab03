# astar(draw, grid, start, end)
# returns True if path found, False otherwise

1. initialize count := 0
2. create an empty priority queue open_heap
3. put (f=0, count, start) into open_heap
4. create came_from map := {}
5. create g_score map for every spot := +infinity
6. g_score[start] := 0
7. create f_score map for every spot := +infinity
8. f_score[start] := heuristic(start.position, end.position)
9. create membership set lookup_set := { start }   # O(1) check for items in heap

10. while open_heap not empty:
    a. handle UI events (e.g. quit)
    b. current := get smallest entry from open_heap (take the spot element)
    c. remove current from lookup_set

    d. if current is end:
         - reconstruct path by following came_from from end to start:
             while current in came_from:
                 current := came_from[current]
                 mark current as path
                 call draw()
         - mark end and start appropriately
         - return True

    e. for each neighbor in current.neighbors:
         - tentative_g := g_score[current] + cost(current, neighbor) -- here cost = 1
         - if tentative_g < g_score[neighbor]:
             * came_from[neighbor] := current
             * g_score[neighbor] := tentative_g
             * f_score[neighbor] := tentative_g + heuristic(neighbor.position, end.position)
             * if neighbor not in lookup_set:
                 - count++
                 - push (f_score[neighbor], count, neighbor) into open_heap
                 - add neighbor to lookup_set
                 - mark neighbor as open (for visualization)

    f. call draw() to update display
    g. if current != start:
         - mark current as closed (visited)

11. end while

12. return False  # no path found