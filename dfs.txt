# DFS(draw, grid: Grid, start: Spot, end: Spot) -> bool
# returns True if path found, False otherwise
# Uses: Spot.neighbors, Spot.make_open(), Spot.make_closed(), Spot.make_path(), draw()

1. if start is None or end is None: return False

2. stack := [start]                      # LIFO stack
3. visited := { start }                  # set of Spot objects already visited
4. came_from := {}                       # map for path reconstruction

5. while stack not empty:
    a. handle UI events (e.g. quit); if quit -> pygame.quit()
    b. current := stack.pop()
    c. if current == end:
         - # reconstruct path by following came_from from end back to start
         - while current in came_from:
               current := came_from[current]
               current.make_path()
               draw()
         - end.make_end(); start.make_start()
         - return True

    d. for each neighbor in current.neighbors:
         - if neighbor not in visited and not neighbor.is_barrier():
               * visited.add(neighbor)
               * came_from[neighbor] := current
               * stack.append(neighbor)
               * neighbor.make_open()      # for visualization

    e. draw()                            # update visualization
    f. if current != start:
         current.make_closed()           # mark as explored/visited

6. return False  # stack exhausted, no path found
