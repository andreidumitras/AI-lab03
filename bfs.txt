# BFS(draw, grid: Grid, start: Spot, end: Spot) -> bool
# returns True if path found, False otherwise
# Uses: Spot.neighbors, Spot.make_open(), Spot.make_closed(), Spot.make_path(), draw()

1. if start is None or end is None: return False

2. from collections import deque
3. queue := deque()
4. queue.append(start)
5. visited := { start }                 # set of Spot objects already visited
6. came_from := {}                       # map for path reconstruction

7. while queue not empty:
    a. handle UI events (e.g. quit); if quit -> pygame.quit()
    b. current := queue.popleft()
    c. if current == end:
         - # reconstruct path by following came_from from end back to start
         - while current in came_from:
               current := came_from[current]
               current.make_path()
               draw()
         - end.make_end(); start.make_start()
         - return True

    d. for each neighbor in current.neighbors:
         - if neighbor not in visited and not neighbor.is_barrier():
               * visited.add(neighbor)
               * came_from[neighbor] := current
               * queue.append(neighbor)
               * neighbor.make_open()      # for visualization

    e. draw()                            # update visualization
    f. if current != start:
         current.make_closed()           # mark as explored/visited

8. return False  # queue exhausted, no path found